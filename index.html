<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Data Nexus - Cyberpunk Visualization</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;900&display=swap');

* { margin:0; padding:0; box-sizing:border-box; }

body { overflow:hidden; background:#000; font-family:'Orbitron', monospace; color:#00ff88; }

#container { position:fixed; width:100%; height:100%; background: linear-gradient(135deg,#000506 0%,#001122 25%,#000814 50%,#001a0a 75%,#000208 100%); }

.grid-overlay { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; opacity:0.04; background-image: linear-gradient(rgba(0,255,136,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,136,0.1) 1px, transparent 1px); background-size:50px 50px; animation:gridShift 20s linear infinite; }
@keyframes gridShift { 0%{transform:translate(0,0);}100%{transform:translate(50px,50px);} }

.scan-line { position:fixed; top:0; left:0; width:100%; height:6px; background:linear-gradient(90deg,transparent 0%,#00ff88 40%,#88ffaa 50%,#00ff88 60%,transparent 100%); box-shadow:0 0 30px #00ff88,0 0 60px rgba(0,255,136,0.6),0 0 100px rgba(0,255,136,0.3); animation:scanMove 3s ease-in-out infinite; }
@keyframes scanMove { 0%,100%{top:0%;opacity:0;}10%,90%{opacity:1;}50%{top:100%;} }

.tech-pattern { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; opacity:0.02; background-image: radial-gradient(circle at 25% 25%, rgba(0,255,136,0.1) 0%, transparent 50%), radial-gradient(circle at 75% 75%, rgba(0,136,255,0.1) 0%, transparent 50%), radial-gradient(circle at 50% 50%, rgba(255,0,136,0.05) 0%, transparent 70%); animation:techPulse 8s ease-in-out infinite; }
@keyframes techPulse {0%,100%{opacity:0.02;transform:scale(1);}50%{opacity:0.06;transform:scale(1.1);} }

.circuit-lines { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; opacity:0.08; background-image: linear-gradient(45deg, transparent 40%, rgba(0,255,136,0.1) 41%, rgba(0,255,136,0.1) 42%, transparent 43%), linear-gradient(-45deg, transparent 40%, rgba(0,136,255,0.1) 41%, rgba(0,136,255,0.1) 42%, transparent 43%); background-size:200px 200px; animation:circuitFlow 15s linear infinite; }
@keyframes circuitFlow {0%{background-position:0px 0px,0px 0px;}100%{background-position:200px 200px,-200px 200px;} }

#hud { position:fixed; top:20px; left:20px; font-size:14px; color:#00ff88; text-transform:uppercase; letter-spacing:2px; z-index:100; background:rgba(0,0,0,0.7); padding:15px 20px; border:1px solid rgba(0,255,136,0.3); border-radius:20px; font-weight:500; backdrop-filter:blur(30px); box-shadow:0 0 20px rgba(0,255,136,0.3), inset 0 1px 0 rgba(0,255,136,0.2), inset 0 0 20px rgba(0,255,136,0.1); transition: all 0.3s ease; }
#hud::before { content:''; position:absolute; top:-1px; left:-1px; right:-1px; bottom:-1px; background:linear-gradient(45deg,#00ff88,transparent,#00ff88); z-index:-1; border-radius:20px; animation:borderGlow 3s ease-in-out infinite; }
@keyframes borderGlow {0%,100%{opacity:0.3;}50%{opacity:0.8;} }

.hud-line { margin:3px 0; display:flex; justify-content:space-between; align-items:center; position:relative; }
.hud-line::after { content:''; position:absolute; right:-10px; top:50%; transform:translateY(-50%); width:4px; height:4px; background:#00ff88; border-radius:50%; animation:hudPulse 2s ease-in-out infinite; }
@keyframes hudPulse {0%,100%{opacity:0.3; box-shadow:0 0 5px #00ff88;}50%{opacity:1; box-shadow:0 0 15px #00ff88;} }

.hud-value { color:#88ffaa; font-weight:600; margin-left:10px; text-shadow:0 0 10px rgba(136,255,170,0.5); }

#status-indicator { width:8px; height:8px; background:#00ff88; border-radius:50%; box-shadow:0 0 10px #00ff88; animation:statusPulse 2s ease-in-out infinite; }
@keyframes statusPulse {0%,100%{opacity:1; transform:scale(1); box-shadow:0 0 10px #00ff88;}50%{opacity:0.5; transform:scale(1.3); box-shadow:0 0 20px #00ff88;} }

#data-stream { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); font-size:48px; font-weight:900; color:#00ff88; text-transform:uppercase; letter-spacing:8px; opacity:0 !important; transition:opacity 1s ease; z-index:100; pointer-events:none; text-shadow:0 0 20px #00ff88,0 0 40px #00ff88,0 0 60px #00ff88; }

.performance-bars { position:fixed; top:20px; right:20px; display:flex; flex-direction:column; gap:8px; z-index:100; }
.perf-bar { width:120px; height:4px; background:rgba(0,0,0,0.8); border:1px solid #00ff88; position:relative; overflow:hidden; }
.perf-bar::before { content:''; position:absolute; top:0; left:0; height:100%; background:linear-gradient(90deg,#ff0088,#00ff88,#0088ff); transition:width 0.3s ease; animation:perfPulse 2s ease-in-out infinite; }
@keyframes perfPulse {0%,100%{opacity:0.8;}50%{opacity:1;} }
.perf-bar.cpu::before { width:75%; } .perf-bar.gpu::before { width:90%; } .perf-bar.memory::before { width:60%; }
.perf-label { font-size:10px; color:#00ff88; text-transform:uppercase; letter-spacing:1px; margin-bottom:2px; }

@media(max-width:850px){.performance-bars{top:10px;right:10px;}.perf-bar{width:80px;height:3px;}}
</style>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
    }
}
</script>
</head>
<body>
<div id="container"></div>
<div class="grid-overlay"></div>
<div class="tech-pattern"></div>
<div class="circuit-lines"></div>
<div class="scan-line"></div>

<div id="hud">
    <div class="hud-line"><span>SYSTEM:</span><span class="hud-value">ONLINE</span><div id="status-indicator"></div></div>
    <div class="hud-line"><span>FPS:</span><span class="hud-value" id="fps-display">60</span></div>
    <div class="hud-line"><span>NODES:</span><span class="hud-value" id="node-display">24000</span></div>
    <div class="hud-line"><span>MODE:</span><span class="hud-value" id="mode-display">DATA STREAM</span></div>
</div>

<div class="performance-bars">
    <div class="perf-label">CPU LOAD</div>
    <div class="perf-bar cpu"></div>
    <div class="perf-label">GPU LOAD</div>
    <div class="perf-bar gpu"></div>
    <div class="perf-label">MEMORY</div>
    <div class="perf-bar memory"></div>
</div>

<div id="data-stream">DATA STREAM</div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

let scene, camera, renderer, dataNodes, composer;
let time = 0;
let nodeCount = 24000;

window.onload = init;

function generateDataStream(i, count) {
    const t = i / count;
    const channelCount = 10;
    const channelIndex = Math.floor(t*channelCount);
    const channelT = (t*channelCount)%1;
    const channelAngle = (channelIndex/channelCount)*Math.PI*2;
    const channelRadius = 20+channelIndex*5;
    const streamLength = 120;
    const packetPosition = channelT*streamLength - streamLength*0.5;
    const helixRadius = 2.5 + Math.sin(channelT*Math.PI*4)*1.5;
    const helixAngle = packetPosition*0.15 + channelAngle;
    return new THREE.Vector3(Math.cos(helixAngle)*(channelRadius+helixRadius), packetPosition, Math.sin(helixAngle)*(channelRadius+helixRadius));
}

function generateHolographicNetwork(i,count){
    const layerCount=8;
    const layerIndex=Math.floor(i/(count/layerCount));
    const nodeInLayer=i % Math.floor(count/layerCount);
    const nodeInLayerT=nodeInLayer/Math.floor(count/layerCount);
    const layerHeight=(layerIndex-layerCount/2)*15;
    const layerRadius=30+Math.sin(layerIndex*0.8)*20;
    const angle=nodeInLayerT*Math.PI*2;
    const yOffset=Math.sin(angle*(4+layerIndex%3))*4;
    return new THREE.Vector3(Math.cos(angle)*layerRadius, layerHeight+yOffset, Math.sin(angle)*layerRadius);
}

function generatePulsarCore(i,count){
    const coreRatio=0.3;
    const coreCount=Math.floor(count*coreRatio);
    if(i<coreCount){
        const t=i/coreCount;
        const angle=t*Math.PI*8 + time*0.05;
        const radius=8+Math.sin(t*Math.PI*4+time*0.1)*2;
        const y=(t-0.5)*20;
        const x=Math.cos(angle)*radius;
        const z=Math.sin(angle)*radius;
        return new THREE.Vector3(x,y,z);
    }else{
        const t=(i-coreCount)/(count-coreCount);
        const angle=t*Math.PI*16 + time*0.02;
        const radius=30+Math.sin(t*Math.PI*4+time*0.05)*5;
        const y=(t-0.5)*40;
        const x=Math.cos(angle)*radius;
        const z=Math.sin(angle)*radius;
        return new THREE.Vector3(x,y,z);
    }
}

function init(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,2000);
    camera.position.set(0,50,120);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry=new THREE.BufferGeometry();
    const positions=new Float32Array(nodeCount*3);
    for(let i=0;i<nodeCount;i++){
        const v = generateDataStream(i,nodeCount);
        positions[i*3]=v.x; positions[i*3+1]=v.y; positions[i*3+2]=v.z;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
    const material=new THREE.PointsMaterial({color:0x00ff88, size:0.4});
    dataNodes=new THREE.Points(geometry,material);
    scene.add(dataNodes);

    composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene,camera);
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth,window.innerHeight),1.2,0.4,0.85);
    composer.addPass(bloomPass);
    composer.addPass(new OutputPass());

    window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);composer.setSize(window.innerWidth,window.innerHeight);});

    animate();
}

// Mouse camera
let mouseX=0, mouseY=0;
document.addEventListener('mousemove', e => { mouseX=(e.clientX/window.innerWidth-0.5)*2; mouseY=(e.clientY/window.innerHeight-0.5)*2; });

// Typing @1ink
const dataStreamEl=document.getElementById('data-stream');
const nameText='@1ink';
let index=0, forward=true;
function typeLoop(){
    if(forward){index++; if(index>=nameText.length){forward=false; setTimeout(typeLoop,800); return;}}
    else{index--; if(index<=0){forward=true; setTimeout(typeLoop,500); return;}}
    dataStreamEl.textContent=nameText.substring(0,index);
    dataStreamEl.style.opacity=1;
    setTimeout(typeLoop,250);
}
typeLoop();

// Animate
let frameCount=0,lastTime=performance.now();
function animate(){
    requestAnimationFrame(animate);
    time+=0.01;

    dataNodes.rotation.y+=0.001;

    // Camera follow mouse
    camera.position.x+=(mouseX*60 - camera.position.x)*0.05;
    camera.position.y+=(-mouseY*30 + 50 - camera.position.y)*0.05;
    camera.lookAt(0,0,0);

    // FPS
    frameCount++;
    const now=performance.now();
    if(now-lastTime>=1000){
        document.getElementById('fps-display').textContent=Math.round(frameCount*1000/(now-lastTime));
        frameCount=0;
        lastTime=now;
    }

    composer.render();
}
</script>
</body>
</html>
