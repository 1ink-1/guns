<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Neural Network</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

<style>
body, html { margin:0; padding:0; overflow:hidden; background:#000; font-family:'Inter',sans-serif; }
canvas { display:block; width:100%; height:100%; }
#typing-text {
    position:absolute; top:20px; left:20px;
    color:#fff; font-weight:600; font-size:24px;
    z-index:10; background:rgba(0,0,0,0.4); padding:6px 12px; border-radius:8px;
    font-family:'Inter',sans-serif;
}
</style>
</head>
<body>
<div id="typing-text"></div>
<canvas id="neural-network-canvas"></canvas>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';

// === Basic Scene Setup ===
const canvas = document.getElementById('neural-network-canvas');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000,0.002);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 22);

const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.setClearColor(0x000000);

// === Starfield ===
function createStarfield() {
    const geo = new THREE.BufferGeometry();
    const positions = [];
    for(let i=0;i<3000;i++){
        const r = THREE.MathUtils.randFloat(20,100);
        const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
        const theta = THREE.MathUtils.randFloat(0, Math.PI*2);
        positions.push(
            r*Math.sin(phi)*Math.cos(theta),
            r*Math.sin(phi)*Math.sin(theta),
            r*Math.cos(phi)
        );
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
    const mat = new THREE.PointsMaterial({ color:0xffffff, size:0.15, transparent:true, opacity:0.8 });
    return new THREE.Points(geo, mat);
}
scene.add(createStarfield());

// === Simple Nodes ===
const nodesGeo = new THREE.BufferGeometry();
const nodeCount = 50;
const nodePositions = [];
for(let i=0;i<nodeCount;i++){
    nodePositions.push(THREE.MathUtils.randFloatSpread(20), THREE.MathUtils.randFloatSpread(10), THREE.MathUtils.randFloatSpread(20));
}
nodesGeo.setAttribute('position', new THREE.Float32BufferAttribute(nodePositions,3));
const nodesMat = new THREE.PointsMaterial({ color:0xff8800, size:0.5 });
const nodes = new THREE.Points(nodesGeo, nodesMat);
scene.add(nodes);

// === Camera movement by mouse ===
let mouseX=0, mouseY=0;
document.addEventListener('mousemove', e=>{
    mouseX = (e.clientX/window.innerWidth - 0.5)*2;  // -1 to 1
    mouseY = (e.clientY/window.innerHeight - 0.5)*2; // -1 to 1
});

// === Typing Effect ===
const textEl = document.getElementById('typing-text');
const nameText = '@1ink';
let index = 0, forward = true;
function typeLoop(){
    if(forward){
        index++;
        if(index >= nameText.length){ forward=false; setTimeout(typeLoop,800); return; }
    } else {
        index--;
        if(index <=0){ forward=true; setTimeout(typeLoop,500); return; }
    }
    textEl.textContent = nameText.substring(0,index);
    setTimeout(typeLoop, 250);
}
typeLoop();

// === Animate Loop ===
function animate(){
    requestAnimationFrame(animate);

    // camera follows mouse
    camera.position.x += (mouseX*10 - camera.position.x)*0.05;
    camera.position.y += (-mouseY*5 - camera.position.y)*0.05;
    camera.lookAt(0,0,0);

    renderer.render(scene,camera);
}
animate();

// === Resize ===
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
  </html>
