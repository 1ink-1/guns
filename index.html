<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neural Network Background</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

<style>
*{margin:0;padding:0;box-sizing:border-box;}
body,html{overflow:hidden;background:#000;font-family:'Inter',sans-serif;}
canvas{display:block;width:100%;height:100%;position:absolute;top:0;left:0;z-index:1;}

.ui-panel{
    position:absolute;
    backdrop-filter:blur(10px);
    background:rgba(0,0,0,0.7);
    border-radius:12px;
    border:1px solid rgba(255,120,50,0.3);
    box-shadow:0 4px 20px rgba(0,0,0,0.5);
    z-index:10;
    padding:15px;
    color:#eee;
}

#typing-text{
    top:20px;
    left:20px;
    font-size:24px;
    font-weight:600;
    position:absolute;
    z-index:10;
    background:rgba(0,0,0,0.4);
    padding:6px 12px;
    border-radius:8px;
}
</style>
</head>
<body>

<div id="typing-text" class="ui-panel"></div>
<canvas id="neural-network-canvas"></canvas>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

// ===== Scene setup =====
const canvas = document.getElementById('neural-network-canvas');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000,0.0015);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1200);
camera.position.set(0,5,22);

const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, powerPreference:"high-performance" });
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.setClearColor(0x000000);

// ===== Starfield =====
function createStarfield(){
    const count=5000, pos=[];
    for(let i=0;i<count;i++){
        const r=THREE.MathUtils.randFloat(40,120);
        const phi=Math.acos(THREE.MathUtils.randFloatSpread(2));
        const theta=THREE.MathUtils.randFloat(0,Math.PI*2);
        pos.push(r*Math.sin(phi)*Math.cos(theta),
                 r*Math.sin(phi)*Math.sin(theta),
                 r*Math.cos(phi));
    }
    const geo=new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
    const mat=new THREE.PointsMaterial({color:0xffffff,size:0.15,sizeAttenuation:true,depthWrite:false,transparent:true,opacity:0.8});
    return new THREE.Points(geo,mat);
}
scene.add(createStarfield());

// ===== Simple Nodes =====
const nodesGeo = new THREE.BufferGeometry();
const nodeCount = 50;
const nodePositions = [];
for(let i=0;i<nodeCount;i++){
    nodePositions.push(THREE.MathUtils.randFloatSpread(20),
                       THREE.MathUtils.randFloatSpread(10),
                       THREE.MathUtils.randFloatSpread(20));
}
nodesGeo.setAttribute('position', new THREE.Float32BufferAttribute(nodePositions,3));
const nodesMat = new THREE.PointsMaterial({ color:0xff8800, size:0.5 });
const nodes = new THREE.Points(nodesGeo, nodesMat);
scene.add(nodes);

// ===== Mouse-based camera movement =====
let mouseX=0, mouseY=0;
document.addEventListener('mousemove', e=>{
    mouseX = (e.clientX/window.innerWidth - 0.5)*2;
    mouseY = (e.clientY/window.innerHeight - 0.5)*2;
});

// ===== Typing effect =====
const textEl = document.getElementById('typing-text');
const nameText = '@1ink';
let index=0, forward=true;

function typeLoop(){
    if(forward){
        index++;
        if(index>=nameText.length){ forward=false; setTimeout(typeLoop,800); return; }
    } else {
        index--;
        if(index<=0){ forward=true; setTimeout(typeLoop,500); return; }
    }
    textEl.textContent = nameText.substring(0,index);
    setTimeout(typeLoop,250);
}
typeLoop();

// ===== Animate loop =====
function animate(){
    requestAnimationFrame(animate);

    // Camera follows mouse
    camera.position.x += (mouseX*10 - camera.position.x)*0.05;
    camera.position.y += (-mouseY*5 - camera.position.y)*0.05;
    camera.lookAt(0,0,0);

    renderer.render(scene,camera);
}
animate();

// ===== Handle resize =====
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>

</body>
</html>
